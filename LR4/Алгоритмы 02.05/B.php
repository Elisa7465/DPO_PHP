<?php 

// Считываем первую строку и извлекаем n (кол-во IP-адресов) и k (целевое кол-во подсетей)
list($n, $k) = array_map('intval', explode(' ', trim(fgets(STDIN))));

// Массив для хранения IP-адресов в виде целых чисел
$ips = [];
for ($i = 0; $i < $n; $i++) {
    $ipStr = trim(fgets(STDIN));    // Считываем IP как строку
    $ips[] = ip2long($ipStr);       // Преобразуем IP в 32-битное число (для удобного сравнения и побитовых операций)
}

// Сортируем IP-адреса — может ускорить работу с уникальностью
sort($ips);

// Функция создаёт маску подсети по длине префикса
function createMask($prefixLength) {
    // Если длина префикса 0, то маска = 0 (все нули), иначе сдвигаем биты влево и отбрасываем лишнее
    return $prefixLength === 0 ? 0 : (0xFFFFFFFF << (32 - $prefixLength)) & 0xFFFFFFFF;
}

// Перебираем маски от /0 до /32 (от самой широкой до самой точной)
// Цель — найти самую широкую (наименьшую по длине префикса) маску, при которой IP разбиваются на ровно k подсетей
for ($prefix = 0; $prefix <= 32; $prefix++) {
    $mask = createMask($prefix); // Генерируем маску для текущего префикса
    $subnets = [];               // Массив для хранения адресов подсетей

    foreach ($ips as $ip) {
        // Для каждого IP применяем маску: это даёт адрес подсети
        $subnets[] = $ip & $mask;
    }

    // Считаем количество уникальных подсетей
    if (count(array_unique($subnets)) == $k) {
        // Если получили нужное количество подсетей — выводим маску в человекочитаемом формате и выходим
        echo long2ip($mask) . PHP_EOL;
        exit;
    }
}

// Если не нашли подходящей маски — выводим -1 (по условию это маловероятно, но перестраховка)
echo "-1\n";
